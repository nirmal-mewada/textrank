that|WDT|BODY_12:BODY_11:BODY_17:BODY_18:BODY_21:ABSTRACT_3:BODY_3:BODY_4:BODY_6:BODY_5:ABSTRACT_4:ABSTRACT_8:BODY_1:BODY_10:BODY_7:ABSTRACT_9:BODY_8:BODY_9|0
which|WDT|BODY_6:BODY_11:BODY_5:BODY_2:BODY_3:BODY_10:BODY_4:BODY_7:BODY_9|0
the slice|DT NN|BODY_5:ABSTRACT_6:ABSTRACT_4:BODY_1:BODY_2:BODY_3:BODY_19:BODY_4:BODY_10:BODY_7:BODY_8:BODY_9|0
it|PRP|BODY_6:BODY_5:BODY_17:BODY_13:BODY_26:BODY_2:BODY_1:BODY_3:BODY_4:BODY_9|0
s|VBZ|BODY_12:BODY_6:BODY_11:BODY_5:BODY_2:BODY_3:BODY_4:BODY_10:BODY_7:BODY_8:BODY_9|0
there|EX|BODY_6:BODY_5:BODY_1:BODY_2:BODY_3:BODY_4:BODY_7|0
slice|NN|BODY_6:BODY_5:BODY_2:BODY_1:BODY_3|0
vertices|NNS|BODY_12:BODY_6:BODY_5:BODY_2:BODY_3:BODY_4:BODY_8|0
the system|DT NN|BODY_6:BODY_12:BODY_16:BODY_15:BODY_2:BODY_4:BODY_7|0
a procedure|DT NN|BODY_5:BODY_18:BODY_15:BODY_13:BODY_3:BODY_4:BODY_10:BODY_7:BODY_9|0
a slice|DT NN|BODY_6:BODY_16:ABSTRACT_2:BODY_2:BODY_24:ABSTRACT_1:BODY_8|0
x|NN|BODY_6:BODY_11:ABSTRACT_11:BODY_13:BODY_2:BODY_3:BODY_14:BODY_10:BODY_8:BODY_9:BODY_20:ABSTRACT_10|0
the sdg|DT NN|BODY_6:BODY_5:BODY_2:BODY_4:BODY_7:BODY_8:BODY_9|0
)|-RRB-|BODY_5:BODY_13:BODY_3:BODY_4:BODY_7:BODY_8:BODY_9|0
the hrb algorithm|DT NN NN|BODY_6:BODY_1:BODY_2:BODY_3:BODY_4:BODY_7|0
we|PRP|BODY_6:BODY_1:BODY_2:BODY_3:BODY_9|0
figure 3|NN CD|BODY_6:BODY_13:BODY_2:BODY_3:BODY_4:BODY_8|0
respect|NN|BODY_6:BODY_12:BODY_11:BODY_5:ABSTRACT_3:BODY_4:BODY_7|0
v|NN|BODY_6:BODY_2:BODY_4:BODY_7|0
a program|DT NN|BODY_11:BODY_5:ABSTRACT_2:BODY_3:BODY_4:BODY_10|0
values|NNS|BODY_6:BODY_12:BODY_5:BODY_11:BODY_13:BODY_4:BODY_7|0
1|CD|BODY_13:BODY_23:BODY_2:BODY_1:BODY_3|0
the procedure|DT NN|BODY_15:BODY_21:BODY_13:BODY_3:BODY_9|0
the algorithm|DT NN|BODY_2:BODY_1:BODY_3|0
the system dependence graph|DT NN NN NN|BODY_5:BODY_2:BODY_4|0
the complexity|DT NN|BODY_1:BODY_2:BODY_4:BODY_7|0
p|NN|BODY_5:BODY_11:BODY_3:BODY_14:BODY_4:BODY_7:BODY_9|0
v hrb|NN NN|BODY_1:BODY_2:BODY_10:BODY_4:BODY_7:BODY_8|0
an hrb slice|DT NN NN|BODY_5:BODY_2:BODY_3:BODY_4|0
call statements|NN NNS|BODY_18:BODY_2:BODY_4:BODY_7|0
summary edges|NN NNS|BODY_6:BODY_11:BODY_1:BODY_3:BODY_7|0
v )|FW -RRB-|BODY_12:BODY_6:BODY_5:BODY_4:BODY_10:BODY_8|0
the vertices|DT NNS|BODY_6:BODY_2:BODY_4|0
slices|NNS|BODY_2:BODY_3|0
a b2 slice|DT NN NN|BODY_5:BODY_2:BODY_1|0
2 )|CD -RRB-|BODY_2:BODY_3:BODY_4:BODY_10|0
( 2|-LRB- CD|BODY_6:BODY_1:BODY_10:BODY_8|0
the program|DT NN|BODY_17:BODY_13:ABSTRACT_8:BODY_3:BODY_7:BODY_8|0
u|NN|BODY_12:BODY_11:BODY_3:BODY_9|0
( 1|-LRB- CD|BODY_6:BODY_5:BODY_9|0
the size|DT NN|BODY_6:BODY_5:BODY_1:BODY_10|0
context|NN|BODY_6:BODY_4:BODY_8:BODY_9|0
e|NN|BODY_3:BODY_10:BODY_4:BODY_7|0
edges|NNS|BODY_1:BODY_3:BODY_10:BODY_4:BODY_8:BODY_9|0
assignment statements|NN NNS|BODY_6:BODY_4:BODY_7:BODY_8|0
the same procedure|DT JJ NN|BODY_12:BODY_11:BODY_4:BODY_8|0
example|NN|BODY_1:BODY_3|0
roll-out|NN|BODY_1:BODY_3:BODY_8|0
procedures|NNS|BODY_14:BODY_4:BODY_7:BODY_9|0
every parameter|DT NN|BODY_2:BODY_3:BODY_7|0
an interprocedural slice|DT JJ NN|BODY_2:BODY_3:ABSTRACT_1|0
the vertex|DT NN|BODY_12:BODY_6:BODY_8:BODY_9|0
a system|DT NN|BODY_2:BODY_3:BODY_10:BODY_4|0
the called procedure|DT VBN NN|BODY_12:BODY_6:BODY_15:BODY_4|0
g 2|VBG CD|BODY_11:BODY_3:BODY_7|0
the edge set|DT NN NN|BODY_6:BODY_11:BODY_15:BODY_4|0
variable x|JJ NN|BODY_6:BODY_14:BODY_8|0
a solution|DT NN|BODY_12:BODY_6:BODY_2:BODY_3|0
version ( 1 )|NN -LRB- CD -RRB-|BODY_5:BODY_3:BODY_8:BODY_9|0
2|CD|BODY_2:BODY_14:BODY_9|0
this paper|DT NN|BODY_1:BODY_2:BODY_7|0
the original system|DT JJ NN|BODY_6:BODY_11:BODY_13:BODY_7|0
weiser|NN|BODY_6:BODY_1:BODY_14:ABSTRACT_1:BODY_4|0
single procedure programs|JJ NN NNS|BODY_18:BODY_2:BODY_7|0
actual-out vertices|JJ NNS|BODY_1:BODY_2:BODY_8|0
calls|NNS|BODY_12:BODY_5:BODY_10|0
procedure dependence graphs|NN NN NNS|BODY_12:BODY_1|0
the theorem|DT NN|BODY_6:BODY_1:BODY_4|0
they|PRP|BODY_2:BODY_3|0
the actual-out vertex|DT JJ NN|BODY_4:BODY_7:BODY_9|0
the proof|DT NN|BODY_2:BODY_1:BODY_3|0
executable slices|JJ NNS|BODY_1:BODY_3|0
procedure|NN|BODY_6:BODY_5:BODY_2|0
a result|DT NN|BODY_3:BODY_4:BODY_9|0
the components|DT NNS|BODY_6:BODY_2:BODY_7|0
the hrb slicing algorithm|DT NN NN NN|BODY_6:BODY_2:BODY_3|0
those|DT|BODY_5:BODY_3|0
main|JJ|BODY_6:BODY_4:BODY_10|0
point p|NN NN|BODY_12:BODY_5:ABSTRACT_11:BODY_21:BODY_13:BODY_4:BODY_7:BODY_8:ABSTRACT_12|0
the formal-in vertex|DT JJ NN|BODY_12:BODY_8:BODY_9|0
mark weiser|NN NN|BODY_2:ABSTRACT_3|0
components|NNS|BODY_6:BODY_15:BODY_2|0
y|NN|BODY_1:BODY_3:BODY_4|0
g roll-out(|VBG JJ|BODY_6:BODY_3:BODY_4:BODY_8|0
them|PRP|BODY_11:BODY_3:BODY_9|0
( v|-LRB- NN|BODY_14:BODY_10|0
this section|DT NN|BODY_1:BODY_2:BODY_7|0
roll-out( slice )|JJ NN -RRB-|BODY_6:BODY_11:BODY_5:BODY_1:BODY_7|0
the statements|DT NNS|BODY_1:BODY_2:BODY_4:BODY_7|0
verticesofslice|NN|BODY_6:BODY_2:BODY_3:BODY_10:BODY_7|0
a reachability problem|DT NN NN|BODY_6:BODY_3|0
the original program|DT JJ NN|BODY_11:BODY_4:BODY_7:BODY_8|0
an sdg|DT NN|BODY_2:BODY_3|0
the entry vertex|DT NN NN|BODY_3:BODY_4|0
these vertices|DT NNS|BODY_15:BODY_10|0
the addition|DT NN|BODY_3:BODY_4|0
the same sequence|DT JJ NN|BODY_6:BODY_11:BODY_10:BODY_4|0
]|NN|BODY_16:BODY_4|0
a subgraph|DT NN|BODY_6:BODY_3:BODY_8|0
intraprocedural slices|JJ NNS|BODY_2:BODY_3|0
part|NN|BODY_1:BODY_2:BODY_4|0
figure 4|NN CD|BODY_3:BODY_4:BODY_9|0
actual-in vertex mismatches|JJ NN NNS|BODY_2:BODY_3:BODY_4|0
the same order|DT JJ NN|BODY_7:BODY_8:BODY_9|0
this|DT|BODY_1|0
a call vertex|DT NN NN|BODY_5:BODY_2|0
the calling context|DT VBG NN|BODY_3:BODY_14|0
three kinds|CD NNS|BODY_2:BODY_4|0
the induced graph isomorphism lemma|DT JJ NN NN NN|BODY_1:BODY_3:BODY_10|0
procedure calls|NN NNS|BODY_6:ABSTRACT_6:BODY_10:BODY_8|0
a collection|DT NN|BODY_12:BODY_11|0
a call statement|DT NN NN|BODY_2:BODY_1|0
all call-sites|DT NNS|BODY_2:BODY_20|0
global variable|JJ JJ|BODY_4:BODY_8|0
the computation|DT NN|BODY_5:BODY_3|0
multiple calls|JJ NNS|BODY_3:BODY_9|0
a control dependence edge|DT NN NN NN|BODY_1:BODY_2|0
the second call-site|DT JJ NN|BODY_6:BODY_9|0
binkley|NN|ABSTRACT_4:BODY_3|0
an executable slice|DT JJ NN|BODY_16:BODY_1:BODY_3|0
intraprocedural slicing|JJ VBG|BODY_5:BODY_2|0
the value|DT NN|BODY_5:BODY_1:BODY_19:BODY_10:BODY_9:ABSTRACT_10|0
an infinite program|DT JJ NN|BODY_2:BODY_4|0
the meanings|DT NNS|BODY_4|0
data dependence edges|NNS NN NNS|BODY_5:BODY_3|0
figure 1|NN CD|BODY_5:BODY_1|0
an exception handler|DT NN NN|BODY_2:BODY_3|0
an actual parameter|DT JJ NN|BODY_5:BODY_9|0
parameter|NN|BODY_6:BODY_2|0
the notion|DT NN|BODY_3:ABSTRACT_1|0
the call|DT NN|BODY_5:BODY_10:BODY_7|0
the definition|DT NN|BODY_7|0
a transfer-in statement|DT JJ NN|BODY_2|0
call sites|NN NNS|BODY_3:BODY_10|0
interprocedural slicing|JJ NN|BODY_2:BODY_4|0
induced edges )|JJ NNS -RRB-|BODY_2:BODY_7|0
the edge|DT NN|BODY_8:BODY_9|0
pass 1|NN CD|BODY_5:BODY_2:BODY_4|0
james lyle and keith gallagher|NNS NN CC NN NN|BODY_2|0
the composition t|DT NN NN|BODY_2|0
the set|DT NN|BODY_3:BODY_4:BODY_8|0
the first call-site|DT JJ NN|BODY_6:BODY_3|0
reps|NNS|BODY_2:ABSTRACT_3|0
vertex v|JJ NN|BODY_2|0
a call-site|DT JJ|BODY_6:BODY_13:BODY_4|0
the three steps|DT CD NNS|BODY_2:BODY_3|0
actual-in vertex v|JJ NN NN|BODY_2:BODY_3|0
lines|NNS|BODY_3:BODY_4|0
loyola college|NN NN|BODY_4|0
8 , 12]|CD , CD|BODY_5|0
code [17]|NN JJ|BODY_3|0
the graph|DT NN|BODY_6:BODY_4:BODY_8|0
{def-order|NN|BODY_12:BODY_8|0
roll-out(|NN|BODY_14:BODY_7|0
executableslice|NN|BODY_2:BODY_4|0
the formal definition|DT JJ NN|BODY_1:BODY_2|0
the formal-out vertex|DT JJ NN|BODY_6:BODY_10|0
all calling contexts|DT VBG NNS|BODY_6:BODY_3|0
the sequence|DT NN|BODY_6:BODY_2|0
the execution|DT NN|BODY_2:BODY_8:BODY_9|0
the value 0|DT NN CD|BODY_3|0
:= b|NN NN|BODY_14|0
call-sites|NNS|BODY_6:BODY_8|0
the three reviewers|DT CD NNS|BODY_3|0
the predicates|DT NNS|BODY_7|0
each vertex or edge occurrence|DT NN CC NN NN|BODY_3|0
the same|DT JJ|BODY_1:BODY_9|0
g|NN|BODY_2:BODY_7|0
terminates|NNS|BODY_13:BODY_7:BODY_8|0
e .g.|NN NN|BODY_10|0
the intuitive definition|DT JJ NN|BODY_2:BODY_4|0
parameters|NNS|BODY_6:BODY_3|0
c|NN|BODY_5:BODY_4|0
the number|DT NN|BODY_13:BODY_2|0
unwanted call-sites|JJ NNS|BODY_9|0
program integration|NN NN|ABSTRACT_6|0
vertex u|JJ NN|BODY_3|0
computer science department|NN NN NN|BODY_3|0
the maximum number|DT JJ NN|BODY_16:BODY_9|0
:= a|NN DT|BODY_15|0
a programmer|DT NN|BODY_2|0
art delcher|NN NN|BODY_2|0
automatic parallelization [2|JJ NN NN|BODY_6|0
case|NN|BODY_4|0
a division-by-zero error|DT NN NN|BODY_1:BODY_7|0
g slice|VBG NN|BODY_12:BODY_5:BODY_1|0
the assignment|DT NN|BODY_2|0
both control edges|DT NN NNS|BODY_11|0
4|CD|BODY_13|0
as|IN|BODY_13|0
c )|NN -RRB-|BODY_2|0
conditional (|JJ -LRB-|BODY_8|0
automatic parallelization|JJ NN|ABSTRACT_5|0
the second step|DT JJ NN|BODY_5:BODY_1|0
roll-out( slice ) and g roll-out(|JJ NN -RRB- CC VBG JJ|BODY_2|0
system|NN|BODY_6:BODY_9|0
separate slices|JJ NNS|BODY_4|0
procedure p|NN NN|BODY_2:BODY_3|0
a def-order edge|DT NN NN|BODY_2:BODY_1|0
correctness|NN|ABSTRACT_6|0
sequential programs|JJ NNS|BODY_3|0
just the components|RB DT NNS|BODY_12:BODY_8|0
a variable x|DT JJ NN|ABSTRACT_5:BODY_10|0
the finite programs|DT JJ NNS|BODY_5|0
smaller ) slices|JJR -RRB- NNS|ABSTRACT_5|0
[5 ]|CD NN|BODY_3|0
a series|DT NN|BODY_5|0
these slices|DT NNS|BODY_2:ABSTRACT_1|0
version|NN|BODY_1:BODY_9|0
this approach|DT NN|BODY_1:BODY_2|0
horwitz|NN|ABSTRACT_2:BODY_1|0
parameter-in|NN|BODY_13|0
procedure main|NN JJ|BODY_5:BODY_7|0
debugging and software maintenance [7|NN CC NN NN NNS|BODY_4|0
's address|POS NN|BODY_2|0
flow edges|NN NNS|BODY_5:BODY_8|0
a and y|DT CC NN|BODY_13|0
executable interprocedural slices|JJ JJ NNS|TITLE_1:BODY_2|0
a )|DT -RRB-|BODY_5|0
program debugging|NN NN|ABSTRACT_4|0
e and h ( e )|NN CC NN -LRB- NN -RRB-|BODY_12|0
the process|DT NN|BODY_2|0
( 2 ) parameters|-LRB- CD -RRB- NNS|BODY_1|0
( induced graph isomorphism lemma )|-LRB- VBN NN NN NN -RRB-|BODY_2|0
correctness definitions|NN NNS|BODY_2|0
new results|JJ NNS|BODY_1|0
proof|NN|BODY_1|0
value-result|NN|BODY_2|0
the semantics|DT NNS|BODY_2|0
the first pass|DT RB NN|BODY_3|0
the following properties|DT VBG NNS|BODY_3|0
a language|DT NN|BODY_2|0
the editor|DT NN|BODY_4|0
a proof|DT NN|ABSTRACT_5|0
c. < < insert|NN NN NN NN|BODY_12|0
data dependences|NNS NNS|BODY_12|0
a call|DT NN|BODY_6|0
the same vertex|DT JJ NN|BODY_11|0
b2 slices|NN NNS|BODY_3|0
g 1 and g 2|VBG CD CC VBG CD|BODY_5:BODY_7|0
 [1|JJ NNS|BODY_3|0
a|DT|BODY_10:BODY_8|0
program dependence|NN NN|BODY_2|0
control edges|NN NNS|BODY_6:BODY_9|0
a procedure call|DT NN NN|BODY_4|0
which parameters and globals|WDT NNS CC NNS|BODY_2|0
a discussion|DT NN|BODY_2|0
4501 north charles street|CD JJ NNS NN|BODY_5|0
q|NN|BODY_6:BODY_1|0
each formal-out vertex|DT JJ RB|BODY_18|0
occurrences|NNS|BODY_5|0
a variety|DT NN|BODY_3|0
figure 2|NN CD|BODY_2|0
parameter passing|NN VBG|BODY_6:BODY_8|0
chapter 8|NN CD|BODY_2|0
finite approximations|JJ NNS|BODY_6|0
[3 ]|CD NN|BODY_17|0
21210-2699|CD|BODY_7|0
all vertices|DT NNS|BODY_3|0
[9]|NN|BODY_5|0
an infinite-loop|DT NN|BODY_2|0
context and treats|NN CC NNS|BODY_6|0
the new slicing algorithm|DT JJ NN NN|BODY_3|0
this algorithm|DT NN|BODY_5:BODY_1|0
algorithm interprocedural slicing|NN JJ VBG|BODY_2|0
an example|DT NN|BODY_1:BODY_3|0
such parameters|JJ NNS|BODY_3|0
a safe value|DT JJ NN|BODY_2|0
that procedure|DT NN|BODY_10:BODY_8|0
the interprocedural slice|DT JJ NN|BODY_2|0
:=|NN|BODY_12|0
regression testing|NN NN|BODY_5|0
an initial-definition vertex|DT NN NN|BODY_5|0
recursion|NN|BODY_2|0
 x|JJ NN|BODY_11|0
statement|NN|BODY_7|0
a mismatch|DT NN|BODY_4|0
division|NN|BODY_10|0
v) )|NN -RRB-|BODY_5:BODY_10:BODY_9|0
the boundaries|DT NNS|BODY_5:ABSTRACT_5|0
the overall complexity|DT JJ NN|BODY_2|0
a fault|DT NN|BODY_9|0
the cost|DT NN|BODY_4|0
different subsets|JJ NNS|BODY_12:BODY_14|0
the least upper|DT JJS JJ|BODY_3|0
each variable that|DT JJ DT|BODY_6:BODY_4|0
the extension|DT NN|BODY_2:BODY_3|0
every edge v|DT NN FW|BODY_2|0
a full slice )|DT JJ NN -RRB-|BODY_8|0
each call site|DT NN NN|BODY_20|0
a semantics|DT NNS|BODY_2|0
1 ) theorem ( syntactic correctness theorem|CD -RRB- NN -LRB- NN NN NN|BODY_2|0
an extension|DT NN|BODY_2:ABSTRACT_1|0
the first call|DT JJ NN|BODY_3|0
parameter c|NN NN|BODY_2|0
whose vertices|WP$ NNS|BODY_6:BODY_8|0
substantial improvements|JJ NNS|BODY_5|0
its finite approximations|PRP$ JJ NNS|BODY_5|0
the first step|DT JJ NN|BODY_1|0
baltimore maryland|NN NN|BODY_6|0
the vertex set|DT JJ NN|BODY_10:BODY_8|0
a path|DT NN|BODY_5:BODY_3|0
one transfer-out statement|CD JJ NN|BODY_6|0
the same type|DT JJ NN|BODY_9|0
a b1 slice|DT JJ NN|BODY_7|0
any one procedure|DT CD NN|BODY_11:BODY_18|0
t -1|NN NN|BODY_3|0
the examples|DT NNS|BODY_3|0
the suggestions|DT NNS|BODY_1|0
this isomorphism|DT NN|BODY_1|0
the names|DT NNS|BODY_4|0
the second call|DT JJ NN|BODY_5:BODY_8|0
[7 ] and algorithm|DT NN CC NN|BODY_3|0
a program slice|DT NN NN|ABSTRACT_2|0
(tcs -cs 2 +np -v|NNP NNP CD NN NN|BODY_2|0
the third step|DT JJ NN|BODY_1:BODY_9|0
[17]|NN|BODY_3|0
the second call statement|DT JJ NN NN|BODY_3|0
the infinite programs|DT JJ NNS|BODY_7|0
the solution|DT NN|BODY_13|0
an actual-out vertex mismatch|DT JJ NN NN|BODY_2|0
variables|NNS|BODY_3|0
the evaluation|DT NN|BODY_10|0
two ways|CD NNS|BODY_2|0
line|NN|BODY_15|0
a called procedure and y|DT VBN NN CC NN|BODY_4|0
this new algorithm|DT JJ NN|BODY_2|0
their algorithm|PRP$ NN|ABSTRACT_2:BODY_1|0
all three points|DT CD NNS|BODY_3|0
output statements|NN NNS|BODY_6|0
every non-def-order edge e|DT JJ NN NN|BODY_10|0
at most|IN JJS|BODY_6|0
a brief summary|DT JJ NN|BODY_2:BODY_1|0
figure|NN|BODY_4|0
the final system slice|DT JJ NN NN|BODY_5|0
executable programs|JJ NNS|ABSTRACT_5:BODY_1:BODY_7|0
actual-in vertex mismatch|JJ NN NN|BODY_8|0
slicing g|NN NN|BODY_2:BODY_7|0
vertexset(|NNS|BODY_8|0
all points|DT NNS|BODY_12|0
a statement|DT NN|BODY_3|0
the call-sites|DT NNS|BODY_2|0
the exposition|DT NN|BODY_6|0
def-order dependence edges|NN NN NNS|BODY_5|0
a summer research grant|DT NN NN NN|BODY_3|0
reference|NN|BODY_3|0
global variable that|JJ JJ DT|BODY_3:BODY_8|0
roll-out( slice ) exists|JJ NN -RRB- VBZ|BODY_4|0
its originating line|PRP$ JJ NN|BODY_6|0
the statement|DT NN|BODY_7|0
input statements|NN NNS|BODY_5|0
the remainder|DT NN|BODY_1|0
an hrb slice executable|DT NN NN NN|BODY_2|0
using weiser|VBG NN|BODY_4|0
> example|IN NN|BODY_6:BODY_24|0
an actual-in vertex|DT JJ NN|BODY_5|0
[6]|NN|BODY_6|0
s.|VBG|BODY_11:BODY_15|0
flow dependence edges|NN NN NNS|BODY_4|0
a slight extension|DT JJ NN|BODY_6|0
a predicate vertex|DT NN NN|BODY_4|0
a parameter-out edge|DT NN NN|BODY_17|0
parameter-in edges|JJ NNS|BODY_12|0
parameter-out edges|JJ NNS|BODY_8|0
the sequences|DT NNS|BODY_3:BODY_10|0
an actual-in vertex mismatch differs|DT JJ NN NN NNS|BODY_3|0
an appropriate initial parameter value|DT JJ JJ NN NN|BODY_9|0
two vertices|CD NNS|BODY_2|0
( g p|-LRB- VBG NN|BODY_8|0
p ( e .g.|NN -LRB- NN NN|BODY_6|0
every edge e|DT NN NN|BODY_8|0
a single procedure|DT JJ NN|BODY_2|0
these procedures|DT NNS|BODY_2|0
a vertex or edge|DT NN CC NN|BODY_5|0
the corresponding actual-out vertex|DT JJ JJ RB|BODY_19|0
system-rather|JJ|BODY_2|0
line [6|NN CD|BODY_8|0
p.|NN|BODY_10:BODY_9|0
.loyola.edu version|NNP NN|BODY_8|0
roll-out( slice ) )|NN NN -RRB- -RRB-|BODY_9|0
a parameter|DT NN|BODY_7:BODY_9|0
entry and call vertices|NN CC NN NNS|BODY_14|0
y (|NN -LRB-|BODY_13|0
pdgs )|NNS -RRB-|BODY_13|0
the necessary actual parameter value|DT JJ JJ NN NN|BODY_11|0
the same control|DT JJ NN|BODY_11|0
a flow dependence edge|DT NN NN NN|BODY_6|0
>|IN|BODY_11|0
:= c |NN NN|BODY_6|0
source )|NN -RRB-|BODY_7|0
coarse grain parallelism|JJ NN NN|BODY_2|0
the first algorithm|DT JJ NN|BODY_3|0
interprocedural control|JJ NN|BODY_17|0
the term|DT NN|BODY_1|0
the called procedure parameter|DT VBN NN NN|BODY_13|0
terms|NNS|BODY_5|0
( 3|-LRB- CD|BODY_16|0
the name space|DT NN NN|BODY_14|0
this phenomenon|DT NN|BODY_2|0
an hrb slice ) traverses call edges|DT NN NN -RRB- NNS NN NNS|BODY_4|0
c :=|NN NN|BODY_8|0
( reachingvertices( g|-LRB- NN NN|BODY_11:BODY_7|0
parameter-out} ) ) b2( g|NN -RRB- -RRB- NN NN|BODY_9|0
the paper|DT NN|BODY_2|0
g p|NN NN|BODY_3|0
its calling contexts|PRP$ VBG NNS|BODY_14|0
3|CD|BODY_10|0
the same data-flow effect|DT JJ JJ NN|BODY_9|0
vertex|NN|BODY_2|0
streams|NNS|BODY_2|0
isomorphic 5|JJ CD|BODY_7|0
an example system|DT NN NN|BODY_2|0
these sequences|DT NNS|BODY_4|0
b1( g|JJ NN|BODY_5|0
formal-out and actual-out vertices|JJ CC JJ NNS|BODY_6|0
the body|DT NN|BODY_5|0
control dependence edges|NN NN NNS|BODY_4|0
control dependent|NN JJ|BODY_11|0
all program points|DT NN NNS|BODY_4|0
more accurately|RBR RB|ABSTRACT_6|0
g 1|VBG CD|BODY_5:BODY_9|0
( b ) call-sites|-LRB- NN -RRB- NNS|BODY_22|0
a semantics-preserving transformation|DT JJ NN|BODY_2|0
a separate name space|DT JJ NN NN|BODY_3|0
insert|NN|BODY_22|0
follows|VBZ|BODY_4|0
the presence|DT NN|BODY_1|0
every vertex|DT NN|BODY_7|0
aliasing|NN|BODY_4|0
input and output|NN CC NN|BODY_5|0
the same nesting level|DT JJ NN NN|BODY_10|0
1 ) ( closure slice|CD -RRB- -LRB- NN NN|BODY_9|0
the corresponding procedure-entry vertex|DT JJ NN RB|BODY_9|0
this slice|DT NN|BODY_14|0
four kinds|CD NNS|BODY_3|0
both|DT|BODY_7|0
target|NN|BODY_6|0
an isomorphism|DT NN|BODY_8|0
the operators|DT NNS|BODY_4|0
polynomial|NN|BODY_4|0
those statements|DT NNS|ABSTRACT_7|0
correctly accounts|JJ NNS|BODY_5|0
the individual passes|DT JJ NNS|BODY_5|0
slice and s.|NN CC NN|BODY_10:BODY_9|0
verticesofslice ( p|NN -LRB- NN|BODY_9|0
a call edge|DT NN NN|BODY_7|0
precise |JJ|BODY_2|0
one transfer-in statement|CD JJ NN|BODY_2|0
more precise executable interprocedural slices|RBR JJ JJ JJ NNS|ABSTRACT_4|0
figure 4 ensures y|NN CD VBZ NN|BODY_5|0
section 2|NN CD|BODY_4|0
algorithm executableslice|NN NN|BODY_3|0
the important point|DT JJ NN|BODY_3|0
intraprocedural edges|JJ NNS|BODY_3|0
one|CD|BODY_14|0
the software maintenance technique|DT NN NN NN|BODY_2|0
v-|NNS|BODY_7|0
a distinguished vertex|DT JJ NN|BODY_3|0
backwards|NNS|BODY_5|0
actual-in vertex  x|JJ JJ NN NN|BODY_5|0
< insert|NN NN|BODY_9|0
each component c -v|DT NN NN NN|BODY_2|0
control|NN|BODY_8|0
( 2 ) two call-sites|-LRB- CD -RRB- CD NNS|BODY_10|0
different actual-in vertices|JJ JJ NNS|BODY_13:BODY_9|0
's such as c|POS JJ IN NN|BODY_7|0
q , q and p|NN , NN CC NN|BODY_5|0
just the dependence edges|RB DT NN NNS|BODY_4|0
each|DT|BODY_13|0
a single main procedure|DT JJ JJ NN|BODY_11|0
actual-in and actual-out ver- tices|JJ CC JJ NNS NNS|BODY_9|0
each procedure|DT NN|BODY_15|0
sites|NNS|BODY_5|0
brevity|NN|BODY_8|0
each component|DT NN|BODY_8|0
[9] )|NN -RRB-|BODY_8|0
the untransformed versions|DT JJ NNS|BODY_9|0
actual-out vertex|JJ NN|BODY_3|0
a vertex v|DT JJ NN|BODY_7|0
the reduced program|DT JJ NN|BODY_4|0
program|NN|BODY_3|0
the traversal|DT NN|BODY_1|0
each call|DT NN|BODY_8|0
a transfer-in vertex|DT JJ NN|BODY_2|0
transformation|NN|BODY_3|0
h ( v|NN -LRB- FW|BODY_4|0
set|NN|BODY_2|0
use|NN|BODY_3|0
a 1-to-1 mapping h|DT JJ NN NN|BODY_3|0
< insert figure|IN NN NN|BODY_5|0
( 1 ) two call-sites|-LRB- CD -RRB- CD NNS|BODY_7|0
parameter vertices|NN NNS|BODY_4|0
the predicate|DT NN|BODY_5|0
version ( 2 )|NN -LRB- CD -RRB-|BODY_7|0
the label|DT NN|BODY_8|0
tcs|NNS|BODY_4|0
the example|DT NN|BODY_12:BODY_1|0
vertices ( statements and predicates|NNS -LRB- NNS CC NNS|BODY_17|0
pass 2|NN CD|BODY_2|0
two kinds|CD NNS|BODY_2|0
a 1-to-1 mapping g|DT JJ NN VBG|BODY_7|0
a parameter-in edge|DT NN NN|BODY_11|0
a recent algorithm|DT JJ NN|ABSTRACT_1|0
point|NN|BODY_2|0
the call vertex|DT NN NN|BODY_12|0
a complete system|DT JJ NN|BODY_10|0
formal-in and formal-out vertices|JJ CC JJ NNS|BODY_6|0
's call-sites|POS NNS|BODY_6|0
np|NN|BODY_12|0
an actual-in mismatch|DT JJ NN|BODY_2|0
system s|NN VBZ|BODY_1|0
large portions|JJ NNS|BODY_6|0
whose components|WP$ NNS|BODY_5|0
an actual-in vertex mismatch|DT JJ NN NN|BODY_4|0
a parameter mismatch|DT NN NN|BODY_10|0
the notation roll-out(|DT NN NN|BODY_2|0
2-3|CD|BODY_5|0
the term program dependence graph |DT NN NN NN NN|BODY_15|0
slicing theorem.|NN NN|BODY_6|0
execution|NN|BODY_4|0
the slicing theorem|DT NN NN|BODY_6|0
version ( 2|NN -LRB- CD|BODY_5:BODY_13|0
variable naming conflicts|JJ NN NNS|BODY_4|0
 respectively )|JJ RB -RRB-|BODY_16|0
) and while-loop statements|-RRB- CC NN NNS|BODY_9|0
16]|CD|BODY_7|0
initial-definitions vertices|NNS NNS|BODY_1|0
slicing|VBG|BODY_1|0
the comments|DT NNS|BODY_1|0
the same label|DT JJ NN|BODY_12|0
this relationship|DT NN|BODY_1|0
the first parameter|DT JJ NN|BODY_5|0
two related mismatch problems|CD JJ NN NNS|BODY_6|0
satisfy|VB|BODY_4|0
 tmp|JJ NN|BODY_7|0
the term  system dependence graph |DT NN NNP NN NN NN|BODY_19|0
previous dependence representations|JJ NN NNS|BODY_7|0
4 (edges|CD NNS|BODY_13|0
author|NN|BODY_1|0
the effects|DT NNS|BODY_7|0
every v|DT NN|BODY_12|0
an sdg g|DT JJ NN|BODY_3|0
the program elements|DT NN NNS|BODY_6|0
the hrb interprocedural slic - ing|DT NN JJ JJ : NN|BODY_3|0
no need|DT NN|BODY_6|0
edge e|NN NN|BODY_14|0
graph g roll-out(|NN NN NN|BODY_12|0
the reduced pro- gram |DT JJ NNS NN|BODY_8|0
interprocedural edges|JJ NNS|BODY_5|0
version ( 2 ) [17]|NN -LRB- CD -RRB- NN|BODY_4|0
individual computation threads|JJ NN NNS|BODY_4|0
transfer-out statements|JJ NNS|BODY_10|0
.e|NN|BODY_10|0
the left|DT NN|BODY_11|0
no further actual-in vertex mismatches|DT JJ JJ NN NNS|BODY_4|0
sdg g|JJ NN|BODY_3|0
closer inspection|RBR NN|BODY_2|0
roll-out( p )|JJ NN -RRB-|BODY_7|0
the technique|DT NN|BODY_1|0
the same edge|DT JJ NN|BODY_13|0
software maintenance|NN NN|ABSTRACT_7|0
the program component|DT NN NN|BODY_10|0
's complexity|POS NN|BODY_4|0
transfer-in statements|JJ NNS|BODY_9|0
its value|PRP$ NN|BODY_7|0
section 3|NN CD|BODY_5|0
different processors|JJ NNS|BODY_5|0
the program components|DT NN NNS|BODY_1|0
two parts|CD NNS|BODY_2|0
a dependence graph|DT NN NN|BODY_4|0
dependences|NNS|BODY_10|0
divisible components|JJ NNS|BODY_8|0
the sdg models|DT NN NNS|BODY_1|0
a pointer|DT NN|BODY_3|0
1 )|CD -RRB-|BODY_2|0
's original interprocedural-slicing algorithm|POS JJ NN NN|ABSTRACT_2|0
the distinction|DT NN|BODY_2|0
the behavior|DT NN|BODY_3|0
at least one corresponding actual-in vertex|IN JJS CD JJ JJ NN|BODY_6|0
an isomorphism f|DT NN NN|BODY_4|0
a pro- cedure|DT JJ NN|BODY_3|0
track|NN|BODY_7|0
call edges|JJ NNS|BODY_10|0
the sets|DT NNS|BODY_3|0
actual-in vertices|JJ NNS|BODY_4|0
two lists|CD NNS|BODY_7|0
10 , 11]|CD , CD|BODY_4|0
linear|NN|BODY_4|0
the hrb slice|DT NN NN|BODY_3|0
the transformed versions|DT VBN NNS|BODY_5|0
some other operation|DT JJ NN|BODY_3|0
two call-sites|CD NNS|BODY_11|0
the total number|DT JJ NN|BODY_5|0
b1(s|NNS|BODY_1|0
an executable program|DT JJ NN|BODY_5|0
zero|CD|BODY_11|0
> 3.3|IN CD|BODY_14|0
the original procedure|DT JJ NN|BODY_14|0
the new algorithm|DT JJ NN|ABSTRACT_7|0
a new scope statement|DT JJ NN NN|BODY_3|0
each expansion step|DT NN NN|BODY_1|0
each vertex|DT NN|BODY_4|0
two call statements|CD NN NNS|BODY_11|0
those elements|DT NNS|BODY_7|0
whose expansion|WP$ NN|BODY_4|0
( executable slice|-LRB- JJ NN|BODY_3|0
2 ( sdg) [9]|CD -LRB- NN NN|BODY_5|0
roll-out( slice ) , roll-out( slice ) and roll-out( s|JJ NN -RRB- , JJ NN -RRB- CC JJ VBZ|BODY_9|0
vertex set v|JJ NN NNS|BODY_5|0
v hrb and system|NN NN CC NN|BODY_6|0
( np -v|-LRB- NN NN|BODY_3|0
a common use|DT JJ NN|BODY_8|0
's behavior|POS NN|BODY_5|0
this system|DT NN|BODY_1|0
the smallest possible slice|DT JJS JJ NN|BODY_3|0
the corollary|DT NN|BODY_5|0
these calling contexts|DT VBG NNS|BODY_7|0
horwitz et|NN NNP|BODY_1|0
a call site|DT NN NN|BODY_3|0
paths|NNS|BODY_5|0
each actual-in vertex|DT JJ RB|BODY_12|0
both assignment|DT NN|BODY_7|0
the dependence graphs|DT NN NNS|BODY_20|0
indivisible com- ponents|JJ NNS NNS|BODY_23|0
graphs|NNS|BODY_16|0
the slice b2( g|DT NN NN NN|BODY_5|0
the polynomial complexity|DT JJ NN|BODY_3|0
the following conditions|DT VBG NNS|BODY_4|0
a copy|DT NN|BODY_8|0
safe approximations|JJ NNS|BODY_3|0
sum|NN|BODY_6|0
the assignment statement|DT NN NN|BODY_7|0
the graph (v|DT NN NN|BODY_6|0
these statements|DT NNS|BODY_8|0
an executable interprocedural slice|DT NN JJ NN|BODY_8|0
inducedgraph( g|NN NN|BODY_4|0
's original interprocedural slicing algorithm|POS JJ JJ NN NN|BODY_2|0
slice terminates|NN NNS|BODY_6|0
a single vertex|DT JJ NN|BODY_3|0
cs|NNS|BODY_8|0
transitive dependences|JJ NNS|BODY_6|0
two different but related  slicing problems|CD JJ CC JJ NN NN NNS|BODY_4|0
only one|RB CD|BODY_8|0
all statements|DT NNS|ABSTRACT_7|0
an occurrence|DT NN|BODY_7|0
the relative order|DT JJ NN|BODY_6|0
a formal-in vertex|DT JJ NN|BODY_4|0
sequences|NNS|BODY_6|0
a non-terminating loop|DT JJ NN|BODY_7|0
the corresponding formal-in vertex|DT JJ JJ RB|BODY_14|0
a program point p|DT NN NN NN|ABSTRACT_4|0
the same values|DT JJ NNS|BODY_10|0
an infinite loop|DT JJ NN|BODY_6|0
a sequence|DT NN|BODY_7|0
's algorithm|POS NN|BODY_5:BODY_7|0
that respects|DT NNS|BODY_8|0
one parameter|CD NN|BODY_25|0
the b2 slice|DT JJ NN|BODY_6|0
a trivial transformation t|DT JJ NN NN|BODY_2|0
the division-by-zero error|DT NN NN|BODY_5|0
none|NN|BODY_4|0
an algorithm|DT NN|BODY_7|0
all statements and predicates|DT NNS CC NNS|BODY_7|0
any input|DT NN|BODY_6:BODY_8|0
explicit the transfer|JJ DT NN|BODY_12|0
imprecise slices|JJ NNS|ABSTRACT_3|0
parameter mismatches|NN NNS|BODY_5|0
a restriction|DT NN|BODY_3|0
the following definition|DT VBG NN|BODY_5|0
no vertex|DT NN|BODY_8|0
statements|NNS|BODY_5|0
inducedgraph|NN|BODY_5|0
v ) and e|NN -RRB- CC NN|BODY_4|0
the steps|DT NNS|BODY_2|0
( a )|-LRB- DT -RRB-|BODY_12|0
a semantically unsatisfactory system|DT RB JJ NN|BODY_5|0
this procedure|DT NN|BODY_7|0
both parameters|DT NNS|BODY_5|0
a vertex u|DT JJ NN|BODY_11|0
an assignment|DT NN|BODY_9|0
a subcomputation|DT NN|BODY_3|0
roll-out( slice|JJ NN|BODY_12|0
executable_slice|NN|BODY_2|0
the same relative order|DT JJ JJ NN|BODY_3|0
vertex y and edge e|NN NN CC NN NN|BODY_3|0
approximate it|JJ PRP|BODY_6|0
respectively g|RB VBG|BODY_3|0
's interprocedural slicing algorithm|POS JJ NN NN|BODY_15|0
procedure boundaries-a solution|NN NN NN|BODY_4|0
two passes|CD NNS|BODY_7|0
an executable system|DT JJ NN|BODY_4|0
the creation|DT NN|BODY_5|0
all the b2 slices|PDT DT NN NNS|BODY_2|0
applications|NNS|BODY_4|0
the terminology|DT NN|BODY_1|0
line 5|NN CD|BODY_3|0
some other actual-in vertex|DT JJ JJ NN|BODY_7|0
smaller )|JJR -RRB-|BODY_4|0
the exhaustive in-line expansion|DT JJ JJ NN|BODY_3|0
an entire program|DT JJ NN|ABSTRACT_3:BODY_3|0
actual-out vertex mismatches|JJ NN NNS|BODY_3|0
single-procedure program p|JJ NN NN|BODY_3|0
( interprocedural data-flow analysis|-LRB- JJ NN NN|BODY_1|0
4]|JJ|BODY_5|0
the actual-in vertex|DT JJ NN|BODY_11|0
that ( 1 ) g roll-out( slice|DT -LRB- CD -RRB- NN NN NN|BODY_2|0
d|JJ|BODY_4|0
a in := sum |DT IN JJ NN|BODY_9|0
i|NN|BODY_2|0
e .g. , statements and predicates )|NN NNP , NNS CC NNS -RRB-|BODY_16|0
call} ) )|NN -RRB- -RRB-|BODY_14|0
one call-site|CD NN|BODY_17|0
version ( 1 ) [13]|NN -LRB- CD -RRB- NN|BODY_14|0
the hrb|DT NN|BODY_1|0
the b2|DT NNS|BODY_3|0
 a in := sum |RB DT IN JJ NN|BODY_8|0
restricting system|VBG NN|BODY_3|0
the statement print|DT NN NN|BODY_4|0
the occurrences|DT NNS|BODY_5|0
the resulting|DT VBG|BODY_11|0
a set|DT NN|BODY_5|0
previous results|JJ NNS|BODY_1|0
collections|NNS|BODY_8|0
line 1|NN CD|BODY_3|0
the reason|DT NN|BODY_1|0
(|-LRB-|BODY_1|0
summary|NN|BODY_1|0
:= z out|JJ FW RP|BODY_11:BODY_13|0
figure 4 )|NN CD -RRB-|BODY_18|0
an intraprocedural edge|DT JJ NN|BODY_4|0
precise executable interprocedural slices|JJ JJ JJ NNS|BODY_6:BODY_4|0
the linear complexity|DT JJ NN|BODY_6|0
a reduced program|DT JJ NN|BODY_9|0
assignments|NNS|BODY_5|0
the corresponding sdg.|DT JJ NN|BODY_3|0
a complete algorithm|DT JJ NN|BODY_1|0
the one|DT CD|BODY_2|0
y and e|NN CC NN|BODY_11|0
each call statement expansion|DT NN NN NN|BODY_7|0
the call-site|DT NN|BODY_11:BODY_13|0
a given set|DT VBN NN|BODY_7|0
variable|JJ|BODY_9|0
's interprocedural-slicing method [17]|POS NN NN NN|BODY_5|0
the vertex or edge occurrence|DT NN CC NN NN|BODY_5|0
a use|DT NN|BODY_13|0
the values|DT NNS|ABSTRACT_9|0
section 4|NN CD|BODY_1|0
this concept|DT NN|BODY_1|0
[15] )|NNP -RRB-|BODY_5|0
def-order , call , or parameter-in edges|NN , NN , CC JJ NNS|BODY_9|0
def-order or parameter-out edges|NN CC JJ NNS|BODY_13|0
3 ( 3 ) input and output|CD -LRB- CD -RRB- NN CC NN|BODY_1|0
note|NN|BODY_1|0
the infinite loop|DT JJ NN|BODY_13|0
two cases|CD NNS|BODY_2|0
certain kinds|JJ NNS|BODY_9|0
the construction cost|DT NN NN|BODY_1|0
a data dependence edge|DT NN NN NN|BODY_1|0
the meaning|DT NN|BODY_1|0
( 3 )|-LRB- CD -RRB-|BODY_1|0
any other algorithmic means|DT JJ JJ NNS|BODY_4|0
section 5|NN CD|BODY_1|0
the actual parameter|DT JJ NN|BODY_10|0
this transformation|DT NN|BODY_1|0
the scope|DT NN|BODY_15|0
flow-dependence edges|NN NNS|BODY_18|0
the chief difficulty|DT JJ NN|BODY_1|0
true )|JJ -RRB-|BODY_16|0
3 techniques|CD NNS|BODY_1|0
( 3 ) theorem ( roll-out theorem [5] )|-LRB- CD -RRB- NN -LRB- NN NN NN -RRB-|BODY_9|0
an actual-out vertex|DT JJ NN|BODY_9|0
any one|DT CD|BODY_7|0
source text|NN NN|BODY_7|0
line 6|NN CD|BODY_6|0
the expanding|DT VBG|BODY_1|0
the source|DT NN|BODY_1|0
actual-in and formal-in vertices|JJ CC JJ NNS|BODY_1|0
intraprocedural slicing-slicing|JJ NN|BODY_1|0
the necessary components|DT JJ NNS|BODY_1|0
hence the same flow dependence edges|RB DT JJ NN NN NNS|BODY_10|0
4 there|CD EX|BODY_1|0
p terminates corollary|NN NNS NN|BODY_11|0
( a ) y|-LRB- DT -RRB- NN|BODY_1|0
( b ) y|-LRB- NN -RRB- NN|BODY_1|0
similarity|NN|BODY_1|0
's entry vertex|POS NN NN|BODY_10|0
's parameters|POS NNS|BODY_16:BODY_14|0
the calling side|DT VBG NN|BODY_7|0
the slices|DT NNS|BODY_1|0
a summary edge|DT NN NN|BODY_1|0
graph g roll-out( slice )|NN NN NN NN -RRB-|BODY_16|0
the system dependence|DT NN NN|BODY_1|0
the program dependence graph [8]|DT NN NN NN NN|BODY_7|0
more precise interprocedural slices|RBR JJ JJ NNS|BODY_1|0
the result|DT NN|BODY_1|0
unwanted program components|JJ NN NNS|BODY_2|0
contrast|NN|BODY_1|0
parameter-in ( or call ) edges|NN -LRB- CC NN -RRB- NNS|BODY_6|0
the choice|DT NN|BODY_1|0
the previous case|DT JJ NN|BODY_1|0
the same text|DT JJ NN|BODY_15|0
the input system|DT NN NN|BODY_7|0
the sdg.|DT NN|BODY_6:BODY_11|0
this vertex or edge|DT NN CC NN|BODY_1|0
5|CD|BODY_1|0
other words|JJ NNS|BODY_1|0
the sliced system|DT JJ NN|BODY_3|0
this work|DT NN|BODY_1|0
this example|DT NN|BODY_1|0
this extension|DT NN|BODY_1|0
c.|NN|BODY_7|0
execu slices|NN NNS|BODY_1|0
auxiliary procedures|JJ NNS|BODY_13|0
5 two ( system dependence|CD CD -LRB- NN NN|BODY_1|0
different actual-out vertices|JJ JJ NNS|BODY_12|0
single-procedure program|JJ NN|BODY_1|0
the syntactic correctness theorem|DT NN NN NN|BODY_1|0
this path corresponds|DT NN NNS|BODY_1|0
x and y|NN CC NN|BODY_1|0
the second parameter|DT JJ NN|BODY_8|0
both b1 and full slices|DT NNS CC JJ NNS|BODY_1|0
( 2 ) theorem ( slicing theorem|-LRB- CD -RRB- NN -LRB- VBG NN|BODY_1|0
a subset v|DT JJ NN|BODY_1|0
just monolithic programs|RB JJ NNS|BODY_11|0
( point|-LRB- NN|BODY_1|0
( induced graph|-LRB- JJ NN|BODY_1|0
actual-out mismatches|JJ NNS|BODY_1|0
no additional slicing|DT JJ NN|BODY_2|0
infinite program roll-out( p )|JJ NN NN NN -RRB-|BODY_3|0
's abstract syntax tree )|POS JJ NN NN -RRB-|BODY_14|0
the calling-context problem|DT JJ NN|BODY_1|0
a non-executable slice|DT JJ NN|BODY_1|0
a further actual-in mismatch|DT JJ JJ NN|BODY_5|0
addition|NN|BODY_1|0
each scope statement|DT NN NN|BODY_1|0
unsolvable data-flow problems|JJ NN NNS|BODY_5|0
unwanted call sites|JJ NN NNS|BODY_5|0
all necessary statements|DT JJ NNS|BODY_7|0
all parameters|DT NNS|BODY_27|0
precise|JJ|BODY_1|0
unnecessary statements|JJ NNS|BODY_5|0
returns|NNS|BODY_11|0
the removal|DT NN|BODY_1|0
only legal execution paths|JJ JJ NN NNS|BODY_9|0
complexity|NN|BODY_1|0
vertex x|NN NN|BODY_1|0
a consequence|DT NN|BODY_1|0
both passes|DT NNS|BODY_1|0
the pdg|DT NN|BODY_1|0
an sdg.|DT NN|BODY_3|0
) terminates|-RRB- NNS|BODY_15|0
the following discussion|DT VBG NN|BODY_1|0
a called procedure|DT VBN NN|BODY_4|0
each program component|DT NN NN|BODY_1|0
introduction|NN|BODY_1|0
the dependence graph|DT NN NN|BODY_10|0
indivisible components|JJ NNS|BODY_19|0
the exception|DT NN|BODY_1|0
the roll-out|DT NN|BODY_1|0
interprocedural slicing-generating|JJ NN|BODY_1|0
a constant|DT JJ|BODY_5|0
a syntactically correct program|DT NN JJ NN|BODY_8|0
the calling|DT NN|BODY_5|0
whose end-points|WP$ NNS|BODY_11|0
its slices|PRP$ NNS|BODY_4|0
multiple procedures|JJ NNS|BODY_5|0
v and u|NN CC NN|BODY_8|0
multi-procedure programs|JJ NNS|BODY_22|0
possible execution paths|JJ NN NNS|BODY_8|0
that assignment|WDT NN|BODY_15|0
( roll-out )|-LRB- NN -RRB-|BODY_1|0
( slicing lemma )|-LRB- NN NN -RRB-|BODY_1|0
( vertex mismatch )|-LRB- NN NN -RRB-|BODY_1|0
( verticesofslice )|-LRB- NN -RRB-|BODY_1|0
each edge|DT NN|BODY_1|0
the hrb algorithm 2.1|DT NN NN CD|BODY_1|0
