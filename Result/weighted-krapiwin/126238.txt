a packaging system|DT NN NN|TITLE_1:BODY_2:BODY_3:ABSTRACT_1|1
that|WDT|BODY_6:BODY_5:ABSTRACT_2:BODY_2:BODY_3:BODY_14:BODY_10:BODY_4:BODY_7|1
programmers|NNS|BODY_6:ABSTRACT_2:BODY_1:BODY_2:BODY_3:BODY_7:BODY_9|1
executables|NNS|BODY_6:BODY_5:ABSTRACT_6:BODY_3:BODY_4:BODY_7:BODY_8|0
the system|DT NN|BODY_5:ABSTRACT_5:BODY_1:ABSTRACT_1:BODY_7:BODY_9|0
a few simple rules|DT JJ JJ NNS|BODY_6:ABSTRACT_6|0
interface software and stubs|NN NN CC NNS|BODY_1:ABSTRACT_1|0
diverse software components|JJ NN NNS|BODY_5:ABSTRACT_3|1
whose run-time performance|WP$ NN NN|ABSTRACT_7:BODY_7|0
heterogeneous programming environments|JJ NN NNS|BODY_6:ABSTRACT_4|1
their application|PRP$ NN|ABSTRACT_4:BODY_3:BODY_4|0
analysis and extraction|NN CC NN|ABSTRACT_3:BODY_3|0
the unix environment|DT NN NN|ABSTRACT_2:BODY_4|0
custom interface code|JJ NN NN|BODY_1:ABSTRACT_1|0
heterogeneous execution environments|JJ NN NNS|TITLE_2|0
each application|DT NN|ABSTRACT_2:BODY_2|0
module interconnection language|NN NN NN|ABSTRACT_7|0
manually integrated applications|RB JJ NNS|ABSTRACT_8|0
polygen|NN|BODY_5:BODY_2:BODY_1:BODY_3:BODY_4:BODY_7|1
modules|NNS|BODY_6:BODY_5:BODY_1:BODY_2:BODY_3:BODY_4:BODY_10:BODY_8|0
we|PRP|BODY_5:BODY_1:BODY_2:BODY_3|1
they|PRP|BODY_6:BODY_2:BODY_1:BODY_3:BODY_10:BODY_4:BODY_7:BODY_8:BODY_9|0
which|WDT|BODY_6:BODY_5:BODY_3:BODY_10:BODY_4|0
stubs|NNS|BODY_6:BODY_5:BODY_1:BODY_2:BODY_3:BODY_4:BODY_7|0
a set|DT NN|BODY_11:BODY_5:BODY_1:BODY_2:BODY_3:BODY_4:BODY_8|0
it|PRP|BODY_6:BODY_2:BODY_1:BODY_3:BODY_4:BODY_8|1
the application|DT NN|BODY_6:BODY_5:BODY_2:BODY_37:BODY_4:BODY_7:BODY_8|0
them|PRP|BODY_6:BODY_5:BODY_2:BODY_1:BODY_3:BODY_4:BODY_8|1
components|NNS|BODY_6:BODY_5:BODY_2:BODY_3:BODY_4:BODY_8|0
an application|DT NN|BODY_1:BODY_2:BODY_3:BODY_4:BODY_7|0
example|NN|BODY_2:BODY_1:BODY_3|0
the two modules|DT CD NNS|BODY_5:BODY_16:BODY_2:BODY_1:BODY_4|0
the configuration|DT NN|BODY_6:BODY_2:BODY_10:BODY_4:BODY_9|1
a configuration|DT NN|BODY_5:BODY_2:BODY_4:BODY_10:BODY_7:BODY_8:BODY_9|0
a partitioning|DT NN|BODY_6:BODY_12:BODY_2:BODY_1:BODY_4|0
the form|DT NN|BODY_5:BODY_2:BODY_3:BODY_4|0
(|-LRB-|BODY_6:BODY_1:BODY_2:BODY_4:BODY_9|0
polylith|NN|BODY_6:BODY_2:BODY_1:BODY_4|0
)|-RRB-|BODY_5:BODY_23:BODY_2:BODY_30|0
a module specification|DT NN NN|BODY_1:BODY_2:BODY_4|0
users|NNS|BODY_6:BODY_5:BODY_4|0
the use|DT NN|BODY_11:BODY_3:BODY_4:BODY_8|0
the makefile|DT NN|BODY_13:BODY_1:BODY_3:BODY_7|0
executable objects|JJ NNS|BODY_6:BODY_1:BODY_2:BODY_4:BODY_7:BODY_9|0
the user|DT NN|BODY_6:BODY_36:BODY_11:BODY_1:BODY_7|0
an environment|DT NN|BODY_12:BODY_6:BODY_5:BODY_2:BODY_1:BODY_3:BODY_4|0
compatibility|NN|BODY_5:BODY_3:BODY_4|0
the instances|DT NNS|BODY_5:BODY_2:BODY_3|0
reuse|NN|BODY_5:BODY_4:BODY_8|0
terms|NNS|BODY_5:BODY_2:BODY_4|0
one|CD|BODY_6:BODY_11:BODY_2|0
|NN|BODY_12:BODY_5:BODY_3:BODY_7|0
the first place|DT JJ NN|BODY_15:BODY_4:BODY_9|0
the interface software|DT NN NN|BODY_5:BODY_2:BODY_3|0
the interfaces|DT NNS|BODY_1:BODY_2:BODY_3|1
interfaces|NNS|BODY_4:BODY_7|1
this|DT|BODY_2:BODY_1:BODY_10|0
the properties and interfaces|DT NNS CC NNS|BODY_5:BODY_3|0
this approach|DT NN|BODY_2:BODY_1:BODY_3|1
a single executable object|DT JJ JJ NN|BODY_3:BODY_7|0
its most important role|PRP$ RBS JJ NN|BODY_1|1
the modules|DT NNS|BODY_2:BODY_7|0
there|EX|BODY_6:BODY_5:BODY_1:BODY_2|0
) ( cadar list|-RRB- -LRB- NN NN|BODY_9|0
use|NN|BODY_13:BODY_4:BODY_9|0
the polylith tcp/ip-based bus|DT NN JJ NN|BODY_12:BODY_3|0
a design|DT NN|BODY_4:BODY_7:BODY_9|0
server|NN|BODY_5:BODY_7:BODY_9|0
the package rule modules(|DT NN NN NNS|BODY_3|0
the same programming language|DT JJ NN NN|BODY_3:BODY_4|0
the name polylith tcpip|DT NN NN NN|BODY_5|0
the composition rules|DT NN NNS|BODY_1:BODY_3:BODY_4|0
source programs|NN NNS|BODY_2:BODY_3|0
the package|DT NN|BODY_12:BODY_5:BODY_2:BODY_1:BODY_4|0
module client f /*|NN NN NN NNS|BODY_2|0
both modules and bindings|DT NNS CC NNS|BODY_2|0
rpc or rev stubs|NN CC NN NNS|BODY_5|0
rule-based software composition models|JJ NN NN NNS|BODY_2|0
figure 3|NN CD|BODY_13:BODY_1:BODY_4|0
a valid partitioning|DT JJ NN|BODY_3:BODY_4:BODY_7|0
efficient remote evaluation mechanisms|JJ JJ NN NNS|BODY_5|0
a single type system|DT JJ NN NN|BODY_4|0
the composition phase )|DT NN NN -RRB-|BODY_3|0
the new 'main' program|DT JJ JJ NN|BODY_3|0
the interprocess communication facilities|DT NN NN NNS|BODY_7|0
an important difference|DT JJ NN|BODY_2|1
the order and type|DT NN CC NN|BODY_4|0
the polylith c_instance client|DT NN NN NN|BODY_5|0
the first executable object|DT JJ NN NN|BODY_26|0
the package tool|DT NN NN|BODY_2:BODY_3|0
the polygen packaging process|DT NN NN NN|BODY_5|0
the graph corresponds|DT NN NNS|BODY_2|0
ext . %d|JJ . NNP|BODY_3:BODY_7|0
. language( client ,'c'|. NN NN NNS|BODY_7|0
the second executable object|DT JJ NN NN|BODY_32|0
lookup(arg1 ) char *arg1|NN -RRB- NN NN|BODY_10|0
. source( client ,'client.c'|. NN NN NNS|BODY_8|0
lookup ( car (|NN -LRB- NN -LRB-|BODY_27|0
h ) ) )|NN -RRB- -RRB- -RRB-|BODY_13|0
techniques|NNS|BODY_11:BODY_2|0
this case|DT NN|BODY_1:BODY_4|0
an abstract description|DT JJ NN|BODY_3:BODY_8|0
a composite specification|DT JJ NN|BODY_2:BODY_1|0
the available hardware configuration|DT JJ NN NN|BODY_9|0
an alternate mil approach|DT JJ JJ NN|BODY_2|0
a design activity|DT NN NN|BODY_2|0
different communication mechanisms|JJ NN NNS|BODY_2|0
the partitioning algorithm|DT NN NN|BODY_2|0
the symbolic name|DT JJ NN|BODY_2|0
source programs and stubs|NN NNS CC NNS|BODY_2|0
integration|NN|BODY_17:BODY_2:BODY_4:BODY_7|0
a package|DT NN|BODY_5:BODY_1:BODY_2:BODY_4|0
communication and interconnection systems|NN CC NN NNS|BODY_3|0
rather inherits transformation capabilities|RB JJ NN NNS|BODY_4|0
test f tool client|NN NN NN NN|BODY_6|0
analyzing source program interfaces|NN NN NN NNS|BODY_3|0
) ( car message|-RRB- -LRB- NN NN|BODY_22|0
a similar  toolkit|DT JJ NN NN|BODY_5|0
a composition and concentrate|DT NN CC NN|BODY_4|0
the host execution environments|DT NN NN NNS|BODY_3|0
a different window system|DT JJ NN NN|BODY_2|0
early stub generation systems|JJ NN NN NNS|BODY_2|0
their configuration management system|PRP$ NN NN NN|BODY_5|0
the modules and bindings|DT NNS CC NNS|BODY_8|0
a software bus organization|DT NN NN NN|BODY_2|0
layer network rpc stubs|NN NN JJ NNS|BODY_6|0
the interconnections and geometry|DT NNS CC NN|BODY_6|0
directed , acyclic graphs|VBN , JJ NNS|BODY_4|0
goal ( 5 )|NN -LRB- CD -RRB-|BODY_2|0
the same executable image|DT JJ JJ NN|BODY_8|0
an example|DT NN|BODY_1:BODY_2|0
the bus implementation b|DT NN NN NN|BODY_6|0
all the source components|DT DT NN NNS|BODY_3|0
interface and module compatibility|NN CC NN NN|BODY_4|0
the prolog inferencing mechanism|DT NN NN NN|BODY_1|0
the particular communication system|DT JJ NN NN|BODY_2|0
printf(  name|NN JJ NN|BODY_13:BODY_7:BODY_9|0
interfacing decisions|NN NNS|BODY_2:BODY_3|0
the stub source programs|DT NN NN NNS|BODY_8|0
the interface description language|DT NN NN NN|BODY_1|0
the principle interconnection subsystem|DT NN NN NN|BODY_3|0
a single composition method|DT JJ NN NN|BODY_7|0
two separate executable objects|CD JJ JJ NNS|BODY_6|0
the root|DT NN|BODY_2:BODY_7:BODY_8|0
a polylith link editor|DT NN NN NN|BODY_4|0
at least one package|IN JJS CD NN|BODY_9|0
the given module specifications|DT VBN NN NNS|BODY_3|0
the horus stub generator|DT NN NN NN|BODY_1|0
a distributed network [13]|DT VBN NN NN|BODY_4|0
the c executable method|DT NN NN NN|BODY_5|0
a polylith network bus|DT NN NN NN|BODY_8|0
the local host workstation|DT JJ NN NN|BODY_8|0
variables and interface names|NNS CC NN NNS|BODY_7|0
interface software|NN NN|BODY_12:BODY_1:BODY_4:BODY_9|0
existing stub generation systems|VBG NN NN NNS|BODY_1|0
stack and jump instructions|NN CC NN NNS|BODY_12|0
the prolog inference engine|DT NN NN NN|BODY_1|0
3.4 interconnection subsystem polygen|CD NN NN NN|BODY_1|0
the x link editor|DT SYM NN NN|BODY_8|0
the test  configuration|DT NN NN NN|BODY_5|0
other configuration management tools|JJ NN NN NNS|BODY_8|0
the necessary interface software|DT JJ NN NN|BODY_4|0
the stub generation process|DT NN NN NN|BODY_5|0
.e|NN|BODY_5:BODY_10:BODY_7|0
the inscape project [11]|DT NN NN NN|BODY_1|0
a read-only system file|DT JJ NN NN|BODY_3|0
the available source programs|DT JJ NN NNS|BODY_5|0
a sample annotated design|DT NN JJ NN|BODY_1|0
a unix makefile [7]|DT NN NN NN|BODY_4|0
the root composition method|DT NN NN NN|BODY_1|0
stubs and makefile rules|NNS CC NN NNS|BODY_5|0
architectural and communication dependencies|JJ CC NN NNS|BODY_5|0
scan -o client.cl client.c|JJ JJ NN NN|BODY_1|0
the underlying inference engine|DT VBG NN NN|BODY_6|0
a single address space|DT JJ NN NN|BODY_4|0
a particular bus implementation|DT JJ NN NN|BODY_5|0
the modified source programs|DT VBN NN NNS|BODY_8|0
the subsequent partition goal|DT JJ NN NN|BODY_4|0
the first two subgoals|DT JJ CD NNS|BODY_1|0
a new composition method|DT JJ NN NN|BODY_1|0
a powerful window system|DT JJ NN NN|BODY_9|0
a target execution environment|DT NN NN NN|BODY_3|0
available execution en- vironments|JJ NN NNS NNS|BODY_5|0
an example composite specification|DT NN JJ NN|BODY_1|0
an underlying communication system|DT JJ NN NN|BODY_5|0
the xcon-in-rime project [16]|DT JJ NN NN|BODY_1|0
a common interface mechanism|DT JJ NN NN|BODY_3|0
an alternate communication system|DT JJ NN NN|BODY_9|0
our approach|PRP$ NN|BODY_6:BODY_5:BODY_4|0
the generated stubs|DT VBN NNS|BODY_2:BODY_1|0
rules|NNS|BODY_6:BODY_2:BODY_3:BODY_4|0
the interconnection capabilities|DT NN NNS|BODY_6:BODY_3|0
a new language|DT JJ NN|BODY_5|1
figure 6|NN CD|BODY_1:BODY_2|0
this example|DT NN|BODY_1:BODY_4|0
part|NN|BODY_6:BODY_2:BODY_4|0
test|NN|BODY_35:BODY_12:BODY_11|0
mils|NNS|BODY_2:BODY_3|0
a single processor|DT JJ NN|BODY_5:BODY_3|0
the composition method|DT NN NN|BODY_3:BODY_8:BODY_9|0
an implementation|DT NN|BODY_6:BODY_3|0
[str] )|NNP -RRB-|BODY_12:BODY_17|0
linkers|NNS|BODY_6:BODY_7:BODY_9|0
tools|NNS|BODY_3:BODY_4|0
the polylith mil|DT NN NN|BODY_2|0
the methods|DT NNS|BODY_2:BODY_4:BODY_9|0
a collection|DT NN|BODY_2:BODY_3|0
our environment|PRP$ NN|BODY_5:BODY_1|0
packaging|NN|BODY_1:BODY_3|0
the compatibility rules|DT NN NNS|BODY_3:BODY_4|0
a module|DT NN|BODY_6:BODY_2:BODY_4|0
polylith and polygen|NN CC NN|BODY_1|1
implementations|NNS|BODY_10:BODY_8|0
a list|DT NN|BODY_5:BODY_2:BODY_4|0
heterogeneity|NN|BODY_5:BODY_4:BODY_8|0
the software bus|DT NN NN|BODY_5:BODY_9|0
the package goal|DT NN NN|BODY_2|0
a keyword|DT NN|BODY_2|0
some cases|DT NNS|BODY_2|0
separate executable objects|JJ JJ NNS|BODY_3:BODY_4|0
a byteswap function|DT NN NN|BODY_2|0
,lookup ,test )|NN NN -RRB-|BODY_26|0
a dispatcher routine|DT NN NN|BODY_2|0
a primitive type|DT JJ NN|BODY_2|0
their design decisions|PRP$ NN NNS|BODY_2|0
an important feature|DT JJ NN|BODY_1|1
this goal|DT NN|BODY_5:BODY_2:BODY_1|0
the integration task|DT NN NN|BODY_2|0
the construction phase|DT NN NN|BODY_1|1
the objects|DT NNS|BODY_4:BODY_7|0
various programming languages|JJ NN NNS|BODY_10|0
integration methods|NN NNS|BODY_6:BODY_5:BODY_1|0
primitive module specifications|JJ JJ NNS|BODY_5:BODY_4|0
custom interface software|NN NN NN|BODY_4|0
= [i1 ,i2|SYM CD NNS|BODY_4|0
source languages|NN NNS|BODY_5:BODY_4|0
a single executable|DT JJ NN|BODY_7|0
two different machines|CD JJ NNS|BODY_6|0
a configuration program|DT NN NN|BODY_3:BODY_7|0
the source programs|DT NN NNS|BODY_2:BODY_3|0
abstract data types|JJ NNS NNS|BODY_2|0
all representation issues|DT NN NNS|BODY_10|0
all inter-module communication|DT JJ NN|BODY_7|0
the same host|DT JJ NN|BODY_3:BODY_10|0
a small set|DT JJ NN|BODY_2|0
all the components|PDT DT NNS|BODY_6:BODY_4|0
the createpackage sub-goal|DT NN NN|BODY_2|0
code generation rules|NN NN NNS|BODY_3:BODY_4|0
client|NN|BODY_3:BODY_20|0
the extra code|DT JJ NN|BODY_2:BODY_1|0
compilers|NNS|BODY_5:BODY_2:BODY_8|0
the phone application|DT NN NN|BODY_13:BODY_10|0
the hrpc project|DT NN NN|BODY_3|0
a method|DT NN|BODY_2|0
each module|DT NN|BODY_6:BODY_5|0
a unix makefile|DT NN NN|BODY_3:BODY_4|0
the commands|DT NNS|BODY_1:BODY_2|0
a site administrator|DT NN NN|BODY_1:BODY_4|0
the 'interface pattern'|DT NN NN|BODY_3|0
the composite specification|DT JJ NN|BODY_1:BODY_7|0
. bind(i1 ,lookup|. NN NN|BODY_25|0
[x-l],c executable )|JJ NN -RRB-|BODY_8|0
the name test |DT NN NN|BODY_3|0
a separate module|DT JJ NN|BODY_3|0
our execution environment|PRP$ NN NN|BODY_1:BODY_3|0
configuration management tools|NN NN NNS|BODY_4|0
two separate objects|CD JJ NNS|BODY_6|0
figure|NN|BODY_6:BODY_5:BODY_9|0
the variable t|DT JJ NN|BODY_4|0
each composition method|DT NN NN|BODY_1:BODY_4|0
( 3 )|-LRB- CD -RRB-|BODY_2|0
the distinct phases|DT JJ NNS|BODY_2|0
[x],c executable )|NN NN -RRB-|BODY_6|0
50 prolog rules|CD NN NNS|BODY_2|0
a bottom-up fashion|DT JJ NN|BODY_2|0
a valid partition|DT JJ NN|BODY_1|0
efficient interface mechanisms|JJ NN NNS|BODY_1|0
our inference capability|PRP$ NN NN|BODY_1|0
such a module|PDT DT NN|BODY_1|0
the -m option|DT NN NN|BODY_1|0
the a2.lsp wrapper|DT JJ NN|BODY_28|0
the design (user|DT NN NN|BODY_3|0
the server )|DT NN -RRB-|BODY_3|0
a tcp/ip-based bus|DT JJ NN|BODY_5:BODY_8|0
( defun mh-dispatcher|-LRB- JJ NN|BODY_18|0
( (equal name|-LRB- JJ NN|BODY_7|0
the integration needs|DT NN NNS|BODY_3|0
certainly more source|RB JJR NN|BODY_6|0
the client specification|DT NN NN|BODY_8|0
horus rpc compilers|NN NN NNS|BODY_2|0
a shared-memory multiprocessor|DT NN NN|BODY_5|0
the a1.c wrapper|DT JJ NN|BODY_22|0
the communication system|DT NN NN|BODY_5|0
. main( client|. NN NN|BODY_10|0
the partition goal|DT NN NN|BODY_2:BODY_8|0
( sender desc|-LRB- NN NN|BODY_14|0
more source code|JJR NN NN|BODY_3|0
the interface descriptions|DT NN NNS|BODY_3:BODY_8|0
a1.o cc -o|DT IN IN|BODY_23|0
a logically-correct design|DT JJ NN|BODY_3|0
all the configuration|PDT DT NN|BODY_3|0
figure 11|NN CD|BODY_1:BODY_2|0
the implementation differences|DT NN NNS|BODY_6|0
( mh-write lookup |-LRB- JJ NN|BODY_26|0
all ,r,null )|DT NN -RRB-|BODY_9|0
client.co csc server.cl|NN NN NN|BODY_9|0
a tedious task|DT JJ NN|BODY_2|0
a predicate expression|DT JJ NN|BODY_5|0
the client .h|DT NN NN|BODY_16|0
the application specification|DT NN NN|BODY_6|0
the variable n|DT JJ NN|BODY_2|0
the properties|DT NNS|BODY_2:BODY_4|0
( caar list|-LRB- NN NN|BODY_8|0
whatever communication system|WDT NN NN|BODY_5|0
several valid partitionings|JJ JJ NNS|BODY_3|0
the inter-process communication|DT JJ NN|BODY_10|0
its own window|PRP$ JJ NN|BODY_7|0
test.co csc client.cl|NN NN NN|BODY_7|0
the instance i2|DT NN NN|BODY_2|0
the integration capabilities|DT NN NNS|BODY_5:BODY_1:BODY_2|0
the server specification|DT NN NN|BODY_10|0
the manual adaptation|DT JJ NN|BODY_2|0
the interfacing mechanisms|DT NN NNS|BODY_1:BODY_4|0
their execution location|PRP$ NN NN|BODY_8|0
]|NN|BODY_6:BODY_3|0
the stub code|DT NN NN|BODY_5|0
) figure 1|-RRB- NN CD|BODY_10|0
a the method|DT DT NN|BODY_6|0
the pattern property|DT NN NN|BODY_2|0
abstract structural descriptions|JJ JJ NNS|BODY_2|0
what interconnection rules|WP NN NNS|BODY_4|0
the variable assignments|DT JJ NNS|BODY_3|0
substantial performance improvements|JJ NN NNS|BODY_2|0
one application component|CD NN NN|BODY_3|0
a unix environment|DT NN NN|BODY_2|0
each new application|DT JJ NN|BODY_3|0
the entire process|DT JJ NN|BODY_2|0
the appropriate commands|DT JJ NNS|BODY_11|0
an abstract characterization|DT JJ NN|BODY_4|0
a straightforward task|DT JJ NN|BODY_2|0
's interconnection capabilities|POS NN NNS|BODY_2|0
software components|NN NNS|BODY_5|0
the remote interfaces|DT JJ NNS|BODY_4|0
cc -c a1.c|IN JJ JJ|BODY_21|0
an annotated design|DT JJ NN|BODY_12|0
the goal|DT NN|BODY_5:BODY_4|0
the construction tools|DT NN NNS|BODY_2|0
the x compiler|DT SYM NN|BODY_6|0
a simple application|DT JJ NN|BODY_12:BODY_1|0
the client component|DT NN NN|BODY_19|0
the program units|DT NN NNS|BODY_10|0
the same problems|DT JJ NNS|BODY_3|0
a distributed application|DT VBN NN|BODY_4|0
a package goal|DT NN NN|BODY_3|0
many possible implementations|JJ JJ NNS|BODY_2|0
a run-time instance|DT NN NN|BODY_4|0
customized interface mechanisms|JJ NN NNS|BODY_4|0
a composition rule|DT NN NN|BODY_2|0
the desired integration|DT VBN NN|BODY_2|0
ipc ) facilities|JJ -RRB- NNS|BODY_11|0
the deductive capabilities|DT JJ NNS|BODY_5|0
printf(  %s|NN NN NN|BODY_2|0
bindall pmodule( client|JJ JJ NN|BODY_6|0
the key phase|DT JJ NN|BODY_2|0
what communication mechanisms|WP NN NNS|BODY_7|0
kcl_instance figure 9|NN NN CD|BODY_11|0
the modules reside|DT NNS NN|BODY_3|0
that increase coupling|WDT NN NN|BODY_7|0
( ,[] )|-LRB- NN -RRB-|BODY_3|0
their source languages|PRP$ NN NNS|BODY_7|0
the manual task|DT JJ NN|BODY_4|0
 )|NN -RRB-|BODY_1|0
the manual tasks|DT JJ NNS|BODY_3|0
else f printf( |RB NN NN|BODY_8|0
the desired geometry|DT VBN NN|BODY_6|0
interface table-lookup list|NN NN NN|BODY_12|0
a target configuration|DT NN NN|BODY_5|0
an existing module|DT VBG NN|BODY_2|0
other execution environments|JJ NN NNS|BODY_3|0
target execution environments|NN NN NNS|BODY_7|0
the simple example|DT JJ NN|BODY_2|0
partitions or instances|NNS CC NNS|BODY_6|0
some economic benefits|DT JJ NNS|BODY_4|0
the source languages|DT NN NNS|BODY_3|0
about 50 rules|IN CD NNS|BODY_2|0
this method|DT NN|BODY_2:BODY_1|0
the source code|DT NN NN|BODY_2|0
the source files|DT NN NNS|BODY_5|0
a2 wrapgen a1.w|DT NN NN|BODY_15|0
a composition|DT NN|BODY_4|0
a single method|DT JJ NN|BODY_4|0
its rule base|PRP$ NN NN|BODY_6|0
the interface name|DT NN NN|BODY_3|0
compile and link|NN CC NN|BODY_6|0
enough inference capability|JJ NN NN|BODY_2|0
two unique modules|CD JJ NNS|BODY_4|0
both user commands|DT NN NNS|BODY_4|0
the configuration program|DT NN NN|BODY_2|0
integrating old implementations|VBG JJ NNS|BODY_7|0
this parameterization|DT NN|BODY_4|0
no mil specification|DT JJ NN|BODY_3|0
module interconnection languages|NN NN NNS|BODY_2|0
available communication media|JJ NN NNS|BODY_6|0
many different environments|JJ JJ NNS|BODY_5|0
our initial experiments|PRP$ JJ NNS|BODY_6|0
whose internal nodes|WP$ JJ NNS|BODY_5|0
distinct source components|JJ NN NNS|BODY_5|0
' object code|'' NN NN|BODY_6|0
an executable application|DT JJ NN|BODY_2|0
the necessary stubs|DT JJ NNS|BODY_3|0
the matchmaker [9]|DT NN NN|BODY_1|0
a connected pair|DT JJ NN|BODY_3|0
select interconnection options|JJ NN NNS|BODY_6|0
the constraints|DT NNS|BODY_4:BODY_9|0
a necessary phase|DT JJ NN|BODY_4|0
just the generation|RB DT NN|BODY_4|0
the module specifications|DT NN NNS|BODY_2|0
the polylith software|DT NN NN|BODY_2|0
new communication resources|JJ NN NNS|BODY_4|0
our demonstration problem|PRP$ NN NN|BODY_6|0
the scan tool|DT JJ NN|BODY_2|0
the stub programs|DT NN NNS|BODY_6|0
stubs and commands|NNS CC NNS|BODY_3|0
bindall figure 5|JJ NN CD|BODY_8|0
more general cases|RBR JJ NNS|BODY_5|0
the logical design|DT JJ NN|BODY_6|0
new compatibility rules|JJ NN NNS|BODY_3|0
some compatibility rules|DT NN NNS|BODY_2|0
a detailed description|DT JJ NN|BODY_1|0
a stub generator|DT NN NN|BODY_3|0
a user-defined identifier|DT JJ NN|BODY_3|0
each desired configuration|DT VBN NN|BODY_1|0
the first phase|DT JJ NN|BODY_1|0
a single root|DT JJ NN|BODY_2|0
a conventional linker|DT JJ NN|BODY_8|0
the partition predicate|DT NN NN|BODY_4|0
a tree|DT NN|BODY_2:BODY_3|0
the system specification|DT NN NN|BODY_2|0
the details|DT NNS|BODY_5:BODY_3|0
mixed language programs|JJ NN NNS|BODY_14|0
the new files|DT JJ NNS|BODY_3|0
the same language|DT JJ NN|BODY_2|0
a root executable|DT NN NN|BODY_13|0
courier [21]|NN NN|BODY_2|0
mil projects|JJ NNS|BODY_2|0
sunrpc [19]|JJ NN|BODY_3|0
appropriate program stubs|JJ NN NNS|BODY_4|0
a particular environment|DT JJ NN|BODY_5:BODY_7|0
's modular structure|POS JJ NN|BODY_3|0
all necessary stubs|DT JJ NNS|BODY_8|0
multiple source files|JJ NN NNS|BODY_2|0
the configuration methods|DT NN NNS|BODY_6|0
software reuse problems|NN NN NNS|BODY_3|0
this execution environment|DT NN NN|BODY_11:BODY_8|0
an editing tool|DT NN NN|BODY_2|0
some desired architecture|DT VBN NN|BODY_6|0
a given environment|DT VBN NN|BODY_2|0
the lisp function|DT NN NN|BODY_1|0
software configurations|NN NNS|BODY_6:BODY_3|0
the integration activity|DT NN NN|BODY_1|0
abstract composition rules|JJ NN NNS|BODY_3|0
a distributed system|DT VBN NN|BODY_7|0
a component|DT NN|BODY_3:BODY_4|0
the leverage|DT NN|BODY_5:BODY_4|0
the hrpc [4|DT NN NNS|BODY_1|0
one execution environment|CD NN NN|BODY_4|0
module specifications|JJ NNS|BODY_2:BODY_1|0
figure 10|NN CD|BODY_2:BODY_1|0
such a capability|PDT DT NN|BODY_1|0
the composition methods|DT NN NNS|BODY_1|0
the list p.|DT NN NN|BODY_4|0
14 , 17|CD , CD|BODY_6|0
the following output|DT VBG NN|BODY_1|0
an execution environment|DT NN NN|BODY_8|0
the components|DT NNS|BODY_3|0
a single configuration|DT JJ NN|BODY_4|0
the last section|DT JJ NN|BODY_4|0
user-defined interface descriptions|JJ NN NNS|BODY_12|0
such a compatibility|PDT DT NN|BODY_1|0
the target environment|DT NN NN|BODY_1|0
the packager system|DT NN NN|BODY_1|0
a code generator|DT NN NN|BODY_7|0
both bus versions|DT NN NNS|BODY_5|0
module composition processes|JJ NN NNS|BODY_5|0
the design specifications|DT NN NNS|BODY_5|0
the given configuration|DT VBN NN|BODY_3|0
assertions and rules|NNS CC NNS|BODY_6|0
the software developer|DT NN NN|BODY_4|0
the name|DT NN|BODY_2:BODY_8|0
i .e|NN NN|BODY_5:BODY_9|0
differing representations|JJ NNS|BODY_5|0
a software component|DT NN NN|BODY_4|0
configuration management programs|NN NN NNS|BODY_11|0
the polylith system|DT NN NN|BODY_1|0
countmain( [x-l],m)|NN NN|BODY_9|0
terconnection system|NN NN|BODY_36|0
the earlier example|DT JJR NN|BODY_1|0
heterogeneous components|JJ NNS|BODY_2:BODY_3|0
assertions|NNS|BODY_3:BODY_4|0
the previous iteration|DT JJ NN|BODY_8|0
an economic necessity|DT JJ NN|BODY_6|0
applications|NNS|BODY_6:BODY_5|0
each heterogeneous configuration|DT JJ NN|BODY_3|0
the given environment|DT VBN NN|BODY_10|0
an appropriate implementation|DT JJ NN|BODY_5|0
the current environment|DT JJ NN|BODY_4|0
many years|JJ NNS|BODY_2|0
the interface description|DT NN NN|BODY_5|0
the cost|DT NN|BODY_6|0
the complete example|DT JJ NN|BODY_13|0
the new platform|DT JJ NN|BODY_5|0
the configuration commands|DT NN NNS|BODY_1|0
interprocess communication primitives|NN NN NNS|BODY_5|0
the compatibility predicate|DT NN NN|BODY_1|0
an xns-based version|DT JJ NN|BODY_5|0
the final application|DT JJ NN|BODY_10|0
a generated implementation|DT VBN NN|BODY_3|0
the final method|DT JJ NN|BODY_1|0
given such constraints|VBN JJ NNS|BODY_1|0
meeting functional requirements|NN JJ NNS|BODY_5|0
the generated implementation|DT VBN NN|BODY_1|0
the packaging system|DT NN NN|BODY_1|0
this resulting package|DT VBG NN|BODY_1|0
each source module|DT NN NN|BODY_1|0
a possible partitioning|DT JJ NN|BODY_1|0
a directed graph|DT VBN NN|BODY_3|0
our inference engine|PRP$ NN NN|BODY_7|0
the extraction tools|DT NN NNS|BODY_1|0
the appropriate stubs|DT JJ NNS|BODY_7|0
the underlying architecture|DT VBG NN|BODY_10|0
figure 5|NN CD|BODY_5:BODY_2:BODY_3|0
both modules|DT NNS|BODY_6:BODY_3|0
many forms|JJ NNS|BODY_2:BODY_3|0
execution location|NN NN|BODY_2|0
module instances|JJ NNS|BODY_5:BODY_4|0
other types|JJ NNS|BODY_5|0
the ability|DT NN|BODY_2|0
existing forms|VBG NNS|BODY_2|0
the potential|DT NN|BODY_2|0
an era|DT NN|BODY_2|0
properties|NNS|BODY_4|0
instances|NNS|BODY_6:BODY_4:BODY_7|0
another form|DT NN|BODY_6|0
the programs|DT NNS|BODY_4|0
c|NN|BODY_2:BODY_9|0
client component|NN NN|BODY_15|0
the bindings|DT NNS|BODY_6:BODY_4|0
source transformations|NN NNS|BODY_6|0
the environment|DT NN|BODY_4|0
section 3.3|NN CD|BODY_3|0
what types|WDT NNS|BODY_3|0
the stubs|DT NNS|BODY_6:BODY_1|0
further parameterizing|JJ VBG|BODY_4|0
the information|DT NN|BODY_3|0
issues|NNS|BODY_3|0
the rules|DT NNS|BODY_1:BODY_4|0
figure 1|NN CD|BODY_2:BODY_4|0
the processes|DT NNS|BODY_3|0
two hosts|CD NNS|BODY_4|0
dependencies|NNS|BODY_6:BODY_5|0
sets|NNS|BODY_6:BODY_4|0
the partitioning|DT NN|BODY_2:BODY_1|0
two modules|CD NNS|BODY_2:BODY_1|0
source components|NN NNS|BODY_4:BODY_8|0
integration activities|NN NNS|BODY_3|0
stub generators|JJ NNS|BODY_3:BODY_10|0
'stub generation|NN NN|BODY_2|0
.umd .edu'|JJ CD|BODY_24|0
